---
title: 'Google Play Store Review Ingestion'
description: 'An automation that fetches Google Play Store reviews, uses an LLM to categorize them, and creates tickets in DevRev.'
---

## Setup

This section guides you on setting up the Google Play Store review ingestion snap-in.

### Prerequisites

- Node.js and `npm` installed.
- A DevRev account with the CLI installed and configured.
- A Fireworks AI API key from the [Fireworks AI website](https://readme.fireworks.ai/docs/quickstart).

### 1. Get the Code

You can start by using the code in the `7-googleplaystore-reviews-ingestion` directory.

### 2. Configure the Snap-in

This snap-in requires several inputs to be configured upon installation:
- **Application ID:** The Google Play ID of your application.
- **Default Part:** The DevRev part where new tickets will be created.
- **Default Owner:** The user or team who will own the new tickets.
- **Fireworks AI API Key:** Your API key for the LLM service.
- **LLM Model:** The specific large language model to use for categorization.

## Manifest

The `manifest.yaml` file defines the slash command, the required inputs (including the Fireworks AI keyring), and the tags used for categorization.

```yaml
version: "2"
name: "Google playstore reviews to Tickets"
description: "Creates tickets from Google playstore reviews and categorize them into one-of `bug`, `feedback`, `feature_request` or `question`."

service_account:
  display_name: Google Playstore Reviews Snap-in

keyrings:
  organization:
    - name: fireworks_api_key
      description: API Key for Fireworks, follow https://readme.fireworks.ai/docs/quickstart to get one.
      types:
        - snap_in_secret
      display_name: Fireworks API Key

inputs:
  organization:
    - name: app_id
      description: "The Google Play id of the application (the ?id= parameter on the url)."
      field_type: text
      is_required: true
      default_value: ""
      ui:
        display_name: Application ID
    - name: default_part_id
      description: "Default part under which to create tickets."
      field_type: id
      id_type:
        - product
        - capability
        - feature
        - enhancement
      is_required: true
      default_value: "don:core:dvrv-us-1:devo/xxx:product/xxx"
      ui:
        display_name: Default Part
    - name: default_owner_id
      description: "Default owner of the tickets."
      field_type: id
      id_type:
        - devu
      is_required: true
      default_value: "don:identity:dvrv-us-1:devo/xxx:devu/xxx"
      ui:
        display_name: Default Owner
    - name: llm_model_to_use
      description: "Which LLM model to use for the review categorization. Not all might work perfectly, generally prefer a larger model with >= 7B params"
      field_type: enum
      allowed_values:
        - qwen-72b-chat
        - elyza-japanese-llama-2-7b-fast-instruct
        - firellava-13b
        - japanese-llava-mistral-7b
        - japanese-stablelm-instruct-beta-70b
        - japanese-stablelm-instruct-gamma-7b
        - japanese-stable-vlm
        - llamaguard-7b
        - llama-v2-13b
        - llama-v2-13b-chat
        - llama-v2-13b-code
        - llama-v2-13b-code-instruct
        - llama-v2-34b-code
        - llama-v2-34b-code-instruct
        - llama-v2-70b
        - llama-v2-70b-chat
        - llama-v2-7b
        - llama-v2-7b-chat
        - llava-codellama-34b
        - llava-v15-13b-fireworks
        - mistral-7b
        - mistral-7b-instruct-4k
        - mixtral-8x7b
        - mixtral-8x7b-instruct
        - qwen-14b-chat
        - qwen-1-8b-chat
        - stablecode
        - stablelm-zephyr-3b
        - starcoder-16b-w8a16
        - starcoder-7b-w8a16
        - yi-34b-200k-capybara
        - yi-6b
        - zephyr-7b-beta
      is_required: true
      default_value: "mixtral-8x7b-instruct"
      ui:
        display_name: LLM Model to use.


tags:
  - name: bug
    description: "This is a bug"
  - name: feature_request
    description: "This is a feature request"
  - name: question
    description: "This is a question"
  - name: feedback
    description: "This is a feedback"
  - name: failed_to_infer_category
    description: "Failed to infer category"


commands:
  - name: playstore_reviews_process
    namespace: devrev
    description: Fetches reviews from Google Playstore and creates tickets
    surfaces:
      - surface: discussions
        object_types:
          - snap_in
    usage_hint: "/playstore_reviews_process [number of reviews to fetch and process]"
    function: process_playstore_reviews


functions:
  - name: process_playstore_reviews
    description: Fetches reviews from Google Playstore and creates tickets
```

## Code

The `7-googleplaystore-reviews-ingestion/code/src/functions/process_playstore_reviews/index.ts` file contains the logic for fetching and processing the reviews. It uses the `google-play-scraper` library to fetch reviews and calls the Fireworks AI LLM to categorize them before creating tickets in DevRev.

```typescript
import {publicSDK } from '@devrev/typescript-sdk';
import * as gplay from "google-play-scraper";
import { ApiUtils, HTTPResponse } from './utils';
import {LLMUtils} from './llm_utils';

export const run = async (events: any[]) => {
  for (const event of events) {
    const endpoint: string = event.execution_metadata.devrev_endpoint;
    const token: string = event.context.secrets.service_account_token;
    const fireWorksApiKey: string = event.input_data.keyrings.fireworks_api_key;
    const apiUtil: ApiUtils = new ApiUtils(endpoint, token);
    // Get the number of reviews to fetch from command args.
    const snapInId = event.context.snap_in_id;
    const devrevPAT = event.context.secrets.service_account_token;
    const baseURL = event.execution_metadata.devrev_endpoint;
    const inputs = event.input_data.global_values;
    let parameters:string = event.payload.parameters.trim();
    const tags = event.input_data.resources.tags;
    const llmUtil: LLMUtils = new LLMUtils(fireWorksApiKey, `accounts/fireworks/models/${inputs['llm_model_to_use']}`, 200);
    let numReviews = 10;
    let commentID : string | undefined;
    if (parameters === 'help') {
      // Send a help message in CLI help format.
      const helpMessage = `playstore_reviews_process - Fetch reviews from Google Play Store and create tickets in DevRev.\n\nUsage: /playstore_reviews_process <number_of_reviews_to_fetch>\n\n\`number_of_reviews_to_fetch\`: Number of reviews to fetch from Google Playstore. Should be a number between 1 and 100. If not specified, it defaults to 10.`;
      let postResp  = await apiUtil.postTextMessageWithVisibilityTimeout(snapInId, helpMessage, 1);
      if (!postResp.success) {
        console.error(`Error while creating timeline entry: ${postResp.message}`);
        continue;
      }
      continue
    }
    let postResp: HTTPResponse = await apiUtil.postTextMessageWithVisibilityTimeout(snapInId, 'Fetching reviews from Playstore', 1);
    if (!postResp.success) {
      console.error(`Error while creating timeline entry: ${postResp.message}`);
      continue;
    }
    if (!parameters) {
      // Default to 10 reviews.
      parameters = '10';
    }
    try {
      numReviews = parseInt(parameters);

      if (!Number.isInteger(numReviews)) {
        throw new Error('Not a valid number');
      }
    } catch (err) {
      postResp  = await apiUtil.postTextMessage(snapInId, 'Please enter a valid number', commentID);
      if (!postResp.success) {
        console.error(`Error while creating timeline entry: ${postResp.message}`);
        continue;
      }
      commentID = postResp.data.timeline_entry.id;
    }
    // Make sure number of reviews is <= 100.
    if (numReviews > 100) {
      postResp  = await apiUtil.postTextMessage(snapInId, 'Please enter a number less than 100', commentID);
      if (!postResp.success) {
        console.error(`Error while creating timeline entry: ${postResp.message}`);
        continue;
      }
      commentID = postResp.data.timeline_entry.id;
    }
    // Call google playstore scraper to fetch those number of reviews.
    let getReviewsResponse:any = await gplay.reviews({
      appId: inputs['app_id'],
      sort: gplay.sort.RATING,
      num: numReviews,
      throttle: 10,
    });
    // Post an update about the number of reviews fetched.
    postResp  = await apiUtil.postTextMessageWithVisibilityTimeout(snapInId, `Fetched ${numReviews} reviews, creating tickets now.`, 1);
    if (!postResp.success) {
      console.error(`Error while creating timeline entry: ${postResp.message}`);
      continue;
    }
    commentID = postResp.data.timeline_entry.id;
    let reviews:gplay.IReviewsItem[] = getReviewsResponse.data;
    // For each review, create a ticket in DevRev.
    for(const review of reviews) {
      // Post a progress message saying creating ticket for review with review URL posted.
      postResp  = await apiUtil.postTextMessageWithVisibilityTimeout(snapInId, `Creating ticket for review: ${review.url}`, 1);
      if (!postResp.success) {
        console.error(`Error while creating timeline entry: ${postResp.message}`);
        continue;
      }
      const reviewText = `Ticket created from Playstore review ${review.url}\n\n${review.text}`;
      const reviewTitle = review.title || `Ticket created from Playstore review ${review.url}`;
      const reviewID = review.id;
      const systemPrompt = `You are an expert at labelling a given Google Play Store Review as bug, feature_request, question or feedback. You are given a review provided by a user for the app ${inputs['app_id']}. You have to label the review as bug, feature_request, question or feedback. The output should be a JSON with fields "category" and "reason". The "category" field should be one of "bug", "feature_request", "question" or "feedback". The "reason" field should be a string explaining the reason for the category. \n\nReview: {review}\n\nOutput:`;
      const humanPrompt = ``;

      let llmResponse = {};
      try {
        llmResponse = await llmUtil.chatCompletion(systemPrompt, humanPrompt, {review: (reviewTitle ? reviewTitle + '\n' + reviewText: reviewText)})
      } catch (err) {
        console.error(`Error while calling LLM: ${err}`);
      }
      let tagsToApply = [];
      let inferredCategory = 'failed_to_infer_category';
      if ('category' in llmResponse) {
        inferredCategory = llmResponse['category'] as string;
        if (!(inferredCategory in tags)) {
          inferredCategory = 'failed_to_infer_category';
        }
      }
      // Create a ticket with title as review title and description as review text.
      const createTicketResp = await apiUtil.createTicket({
        title: reviewTitle,
        tags: [{id: tags[inferredCategory].id}],
        body: reviewText,
        type: publicSDK.WorkType.Ticket,
        owned_by: [inputs['default_owner_id']],
        applies_to_part: inputs['default_part_id'],
      });
      if (!createTicketResp.success) {
        console.error(`Error while creating ticket: ${createTicketResp.message}`);
        continue;
      }
      // Post a message with ticket ID.
      const ticketID = createTicketResp.data.work.id;
      const ticketCreatedMessage = inferredCategory != 'failed_to_infer_category' ? `Created ticket: <${ticketID}> and it is categorized as ${inferredCategory}` : `Created ticket: <${ticketID}> and it failed to be categorized`;
      const postTicketResp: HTTPResponse  = await apiUtil.postTextMessageWithVisibilityTimeout(snapInId, ticketCreatedMessage, 1);
      if (!postTicketResp.success) {
        console.error(`Error while creating timeline entry: ${postTicketResp.message}`);
        continue;
      }
    }
    // Call an LLM to categorize the review as Bug, Feature request, or Question.
  }
};

export default run;
```

## Run

This snap-in is designed to be run from within the DevRev UI after it has been installed and configured.

1.  Go to a discussion in DevRev.
2.  Type the slash command `/playstore_reviews_process [number]` and press Enter. For example, to fetch 20 reviews, you would type:
    ```
    /playstore_reviews_process 20
    ```

> **Note:** Due to the reliance on external services (Google Play Store, Fireworks AI) and the need for specific configuration (App ID, API Keys), this snap-in cannot be effectively tested with a local fixture.

## Verify

After running the slash command, the snap-in will post a series of status updates in the discussion. Once it has finished processing, you can verify its execution by:

1.  **Checking for new tickets:** Navigate to the part you configured as the "Default Part". You should see new tickets created for each review fetched from the Google Play Store.
2.  **Checking the tags:** Each new ticket should be tagged as `bug`, `feature_request`, `question`, or `feedback` based on the LLM's categorization. If the categorization fails, it will be tagged as `failed_to_infer_category`.
